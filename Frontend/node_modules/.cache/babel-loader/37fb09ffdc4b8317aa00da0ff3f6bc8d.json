{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.size = exports.default = exports.IconWrapper = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _theme = require(\"@atlaskit/theme\");\n\nvar _constants = require(\"../constants\");\n\nvar getSize = function getSize(props) {\n  if (props.size) {\n    return \"height: \".concat(_constants.sizes[props.size], \"; width: \").concat(_constants.sizes[props.size], \";\");\n  }\n\n  return null;\n};\n\nvar IconWrapper = _styledComponents.default.span.withConfig({\n  displayName: \"Icon__IconWrapper\",\n  componentId: \"dyhwwi-0\"\n})([\"\\n  \", \" color: \", \";\\n  display: inline-block;\\n  fill: \", \";\\n  flex-shrink: 0;\\n  line-height: 1;\\n\\n  > svg {\\n    \", \" max-height: 100%;\\n    max-width: 100%;\\n    overflow: hidden;\\n    pointer-events: none;\\n    vertical-align: bottom;\\n  }\\n  /* Stop-color doesn't properly apply in chrome when the inherited/current color changes.\\n   * We have to initially set stop-color to inherit (either via DOM attribute or an initial CSS\\n   * rule) and then override it with currentColor for the color changes to be picked up.\\n   */\\n  stop {\\n    stop-color: currentColor;\\n  }\\n\"], getSize, function (p) {\n  return p.primaryColor || 'currentColor';\n}, function (p) {\n  return p.secondaryColor || _theme.colors.background;\n}, getSize);\n\nexports.IconWrapper = IconWrapper;\n\nvar Icon =\n/*#__PURE__*/\nfunction (_Component) {\n  (0, _inherits2.default)(Icon, _Component);\n\n  function Icon() {\n    (0, _classCallCheck2.default)(this, Icon);\n    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Icon).apply(this, arguments));\n  }\n\n  (0, _createClass2.default)(Icon, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          Glyph = _this$props.glyph,\n          dangerouslySetGlyph = _this$props.dangerouslySetGlyph,\n          onClick = _this$props.onClick,\n          primaryColor = _this$props.primaryColor,\n          secondaryColor = _this$props.secondaryColor,\n          size = _this$props.size; // handling the glyphs as strings\n\n      if (dangerouslySetGlyph) {\n        return _react.default.createElement(IconWrapper, {\n          onClick: onClick,\n          primaryColor: primaryColor,\n          secondaryColor: secondaryColor,\n          size: size,\n          \"aria-label\": this.props.label,\n          dangerouslySetInnerHTML: {\n            __html: Icon.insertDynamicGradientID(dangerouslySetGlyph)\n          }\n        });\n      } // handling the glyphs when passed through as functions\n\n\n      return _react.default.createElement(IconWrapper, {\n        onClick: onClick,\n        primaryColor: primaryColor,\n        secondaryColor: secondaryColor,\n        size: size,\n        \"aria-label\": this.props.label\n      }, Glyph ? _react.default.createElement(Glyph, {\n        role: \"presentation\"\n      }) : null);\n    }\n  }], [{\n    key: \"insertDynamicGradientID\",\n\n    /* Icons need unique gradient IDs across instances for different gradient definitions to work\n     * correctly.\n     * A step in the icon build process replaces linear gradient IDs and their references in paths\n     * to a placeholder string so we can replace them with a dynamic ID here.\n     * Replacing the original IDs with placeholders in the build process is more robust than not\n     * using placeholders as we do not have to rely on regular expressions to find specific element\n     * to replace.\n     */\n    value: function insertDynamicGradientID(svgStr) {\n      var id = (0, _uuid.default)();\n      var replacedSvgStr = svgStr.replace(/id=\"([^\"]+)-idPlaceholder\"/g, \"id=$1-\".concat(id)).replace(/fill=\"url\\(#([^\"]+)-idPlaceholder\\)\"/g, \"fill=\\\"url(#$1-\".concat(id, \")\\\"\"));\n      return replacedSvgStr;\n    }\n  }]);\n  return Icon;\n}(_react.Component);\n\nexports.default = Icon;\n(0, _defineProperty2.default)(Icon, \"defaultProps\", {\n  onClick: function onClick() {}\n});\nvar size = Object.keys(_constants.sizes).reduce(function (p, c) {\n  return Object.assign(p, (0, _defineProperty2.default)({}, c, c));\n}, {});\nexports.size = size;","map":null,"metadata":{},"sourceType":"script"}