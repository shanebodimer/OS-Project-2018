{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/* eslint-disable no-console */\n// While in dev preview console.info will be used\n\n/* eslint-disable react/no-unused-prop-types */\n\nimport React, { Component } from 'react';\nimport { colors } from '@atlaskit/theme';\nimport styled from 'styled-components';\nimport FieldWrapper, { HelperText, Label } from './styled/Field';\nimport { ValidatorMessage } from './';\nvar RequiredIndicator = styled.span.withConfig({\n  displayName: \"Field__RequiredIndicator\",\n  componentId: \"sc-6y3zfq-0\"\n})([\"\\n  color: \", \";\\n  padding-left: 2px;\\n\"], colors.red); // TODO: Decide & implement how multiple error messages should be displayed. Likely an UO list\n\nvar messageSeperator = ' ';\n\nvar Field =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Field, _Component);\n\n  function Field(_props) {\n    var _this;\n\n    _classCallCheck(this, Field);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Field).call(this, _props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getComponentFromProps\", function (props) {\n      // Field must have component passed in or a single child\n      if (React.Children.only(props.children) && props.component) {\n        console.warn('Field expects the component to be passed as a child OR component. Both have been passed and child is being used.');\n      } else if (!React.Children.only(props.children) && !props.component) {\n        console.warn('Field must have one valid child which is a field component. E.g FieldText, Select');\n      }\n\n      return React.Children.only(props.children) || props.component || {};\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getFieldStateFromProps\", function (props) {\n      var id = props.id,\n          name = props.name,\n          label = props.label,\n          validators = props.validators,\n          isInvalid = props.isInvalid,\n          invalidMessage = props.invalidMessage,\n          validMessage = props.validMessage,\n          isRequired = props.isRequired,\n          helperText = props.helperText,\n          validateOnChange = props.validateOnChange,\n          validateOnBlur = props.validateOnBlur,\n          validateOnInvalid = props.validateOnInvalid;\n\n      var childComponent = _this.getComponentFromProps(props);\n\n      var fieldState = {\n        validators: validators,\n        isInvalid: isInvalid,\n        invalidMessage: invalidMessage,\n        validMessage: validMessage,\n        isRequired: isRequired,\n        name: childComponent.props.name || name,\n        id: childComponent.props.id || id || name,\n        label: childComponent.props.label || label,\n        value: childComponent.props.value || '',\n        validate: _this.validate,\n        helperText: helperText,\n        validateOnChange: validateOnChange,\n        validateOnBlur: validateOnBlur,\n        validateOnInvalid: validateOnInvalid,\n        componentType: childComponent.props.componentType || childComponent.type.name,\n        invalidMessages: []\n      }; // For some components like Checkbox that are wrapped in withTheme and exported via anon function\n      // we need to check for known props to idenitfy them. TODO: Fix this in the affected components and remove this hack\n\n      if (!fieldState.componentType || !fieldState.componentType.length) {\n        // Checkbox stateless\n        if (childComponent.props.isChecked !== undefined) fieldState.componentType = 'CheckboxStateless';\n      }\n\n      return fieldState;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"getValueFromEvent\", function () {// Can we use\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleOnChange\", function (event, meta) {\n      var fieldState = _this.state.fieldState; // Call any onChange defined for Field or the component.\n      // This is required to support stateless components\n\n      if (_this.state.component.props && _this.state.component.props.onChange) {\n        _this.state.component.props.onChange(event);\n      } // TODO: review if we need to expose this? Might make more sense to just have an onUpdate which fires\n      // when fieldState is updated\n\n\n      if (_this.props.onChange) {\n        _this.props.onChange(event, meta);\n      } // TODO: move mapping event types to field components to json\n      // Most Inputs - Event from HTMLInput | Event\n      // Checkbox\n\n\n      if (_this.state.fieldState.componentType === 'Checkbox') {\n        fieldState.value = event.isChecked ? event.value : ''; // Stateless checkbox\n      } else if (_this.state.fieldState.componentType === 'CheckboxStateless') {\n        fieldState.value = event.currentTarget.checked ? event.currentTarget.value : ''; // Most Inputs - Event from HTMLInput | Event\n      } else if (event && event.target) {\n        fieldState.value = event.target.value || ''; // Strings from inputs, objects & arrays of objects from select\n      } else if (event) {\n        fieldState.value = event; // Default to empty string\n      } else {\n        fieldState.value = '';\n      } // Update Field State and pass on\n\n\n      _this.setState({\n        fieldState: fieldState\n      }); // Update form field state from the validate result or use the current state\n\n\n      if (_this.props.validateOnChange) {\n        _this.updateFormState(_this.validate());\n      } else {\n        _this.updateFormState(_this.state.fieldState);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleOnBlur\", function () {\n      if (_this.props.validateOnBlur) {\n        _this.updateFormState(_this.validate());\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"validate\", function () {\n      var _this$state$fieldStat = _this.state.fieldState,\n          validators = _this$state$fieldStat.validators,\n          value = _this$state$fieldStat.value;\n      var isRequired = _this.props.isRequired;\n\n      var _this$state$fieldStat2 = _this.state.fieldState,\n          isInvalid = _this$state$fieldStat2.isInvalid,\n          invalidMessage = _this$state$fieldStat2.invalidMessage,\n          validMessage = _this$state$fieldStat2.validMessage,\n          invalidMessages = _this$state$fieldStat2.invalidMessages,\n          rest = _objectWithoutProperties(_this$state$fieldStat2, [\"isInvalid\", \"invalidMessage\", \"validMessage\", \"invalidMessages\"]);\n\n      var result = true;\n      var invalid = '';\n      var valid = '';\n      var invalidCount = 0;\n      var validatedFieldState = {}; // Is the field required?\n\n      if (isRequired && !value || isRequired && !String(value).trim().length) {\n        invalidCount++;\n        invalid = 'This field is required';\n      } else if (validators && validators.length) {\n        for (var i = 0; i < validators.length; i++) {\n          if (validators[i].props.func) {\n            result = validators[i].props.func(value, validators[i].props.options); // Invert result if validOn prop is false\n\n            if (validators[i].props.validOnFalse) result = !result; // Most validators will only have an invalid message\n\n            if (result) {\n              valid = valid.concat(validators[i].props.valid + messageSeperator);\n            } else {\n              invalidCount++;\n              invalid = invalid.concat(validators[i].props.invalid + messageSeperator);\n              invalidMessages.push(validators[i].props.invalid);\n            }\n          }\n        }\n      }\n\n      validatedFieldState = {\n        fieldState: _objectSpread({\n          isInvalid: !!invalidCount,\n          invalidMessage: invalid,\n          invalidMessages: invalidMessages,\n          validMessage: valid\n        }, rest)\n      };\n\n      _this.setState(validatedFieldState);\n\n      return validatedFieldState.fieldState;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateFormState\", function (fieldState) {\n      if (_this.props.form && _this.props.form.setFieldState) {\n        _this.props.form.setFieldState(fieldState || _this.state.fieldState);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderLabel\", function () {\n      if (_this.props.label && _this.props.label.length) {\n        return React.createElement(Label, {\n          htmlFor: _this.props.id\n        }, _this.props.label, _this.props.isRequired ? React.createElement(RequiredIndicator, {\n          role: \"presentation\"\n        }, \"*\") : null);\n      }\n\n      return null;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderFieldComponent\", function () {\n      var _this$state$fieldStat3 = _this.state.fieldState,\n          id = _this$state$fieldStat3.id,\n          name = _this$state$fieldStat3.name,\n          isInvalid = _this$state$fieldStat3.isInvalid,\n          isRequired = _this$state$fieldStat3.isRequired,\n          label = _this$state$fieldStat3.label,\n          invalidMessage = _this$state$fieldStat3.invalidMessage;\n      var component = _this.state.component;\n      var validationState = 'default';\n\n      if (component) {\n        // validationState & validationMessage are used to support AtlaskitSelect dev preview\n        if (isInvalid !== undefined) {\n          validationState = isInvalid ? 'error' : 'success';\n        }\n\n        return React.cloneElement(component, {\n          id: id,\n          name: name,\n          isInvalid: isInvalid,\n          isRequired: isRequired,\n          label: label,\n          invalidMessage: invalidMessage,\n          isLabelHidden: true,\n          isValidationHidden: true,\n          validationMessage: invalidMessage,\n          validationState: validationState,\n          onChange: _this.handleOnChange,\n          onUpdate: _this.handleOnChange,\n          onBlur: _this.handleOnBlur\n        });\n      }\n\n      return null;\n    });\n\n    _this.state = {\n      fieldState: _this.getFieldStateFromProps(_props),\n      component: _this.getComponentFromProps(_props)\n    }; // Register the field in the parent form if there is one\n\n    if (_props.form && _this.state.fieldState) _props.form.registerField(_this.state.fieldState);\n    return _this;\n  }\n  /** Register the field in the form if there is one */\n\n\n  _createClass(Field, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {}\n    /** Handle prop or children prop changes */\n\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState({\n        fieldState: this.getFieldStateFromProps(nextProps),\n        component: this.getComponentFromProps(nextProps)\n      });\n    }\n    /** Return the component from children or the component prop */\n\n  }, {\n    key: \"render\",\n\n    /**\n     * When we render Label, Helper & Validation are only handled only if passed as props. This allows for\n     * components that currently roll their own to still be wrapped by Field.\n     */\n    value: function render() {\n      var _this$state$fieldStat4 = this.state.fieldState,\n          helperText = _this$state$fieldStat4.helperText,\n          isInvalid = _this$state$fieldStat4.isInvalid,\n          invalidMessage = _this$state$fieldStat4.invalidMessage,\n          validMessage = _this$state$fieldStat4.validMessage;\n      return React.createElement(FieldWrapper, null, this.renderLabel(), this.renderFieldComponent(), helperText && helperText.length ? React.createElement(HelperText, null, helperText) : null, React.createElement(ValidatorMessage, {\n        isInvalid: isInvalid,\n        validMessage: validMessage,\n        invalidMessage: invalidMessage\n      }));\n    }\n  }]);\n\n  return Field;\n}(Component);\n\n_defineProperty(Field, \"defaultProps\", {\n  validators: [],\n  isInvalid: undefined,\n  invalidMessage: '',\n  validMessage: '',\n  helperText: '',\n  validateOnChange: false,\n  validateOnBlur: true,\n  validateOnInvalid: true\n});\n\nexport { Field as default };","map":null,"metadata":{},"sourceType":"module"}