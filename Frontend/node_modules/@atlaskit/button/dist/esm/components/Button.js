import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import styled from 'styled-components';
import { withAnalyticsEvents, withAnalyticsContext, createAndFireEvent } from '@atlaskit/analytics-next';
import withDeprecationWarnings from './withDeprecationWarnings';
import getButtonProps from './getButtonProps';
import CustomComponentProxy from './CustomComponentProxy';
import getButtonStyles from '../styled/getButtonStyles';
import ButtonContent from '../styled/ButtonContent';
import ButtonWrapper from '../styled/ButtonWrapper';
import IconWrapper from '../styled/IconWrapper';
import LoadingSpinner from '../styled/LoadingSpinner';

var _require = require('../../package.json'),
    packageName = _require.name,
    packageVersion = _require.version;

var StyledButton = styled.button.withConfig({
  displayName: "Button__StyledButton",
  componentId: "sc-1o41kgk-0"
})(["\n  ", ";\n"], getButtonStyles);
StyledButton.displayName = 'StyledButton'; // Target the <a> here to override a:hover specificity.

var StyledLink = styled.a.withConfig({
  displayName: "Button__StyledLink",
  componentId: "sc-1o41kgk-1"
})(["\n  a& {\n    ", ";\n  }\n"], getButtonStyles);
StyledLink.displayName = 'StyledLink';
var StyledSpan = styled.span.withConfig({
  displayName: "Button__StyledSpan",
  componentId: "sc-1o41kgk-2"
})(["\n  ", ";\n"], getButtonStyles);
StyledSpan.displayName = 'StyledSpan';

var createStyledComponent = function createStyledComponent() {
  // Override pseudo-state specificity.
  // This is necessary because we don't know what DOM element the custom component will render.
  var component = styled(CustomComponentProxy).withConfig({
    displayName: "Button__component",
    componentId: "sc-1o41kgk-3"
  })(["&,a&,&:hover,&:active,&:focus{", "}"], getButtonStyles);
  component.displayName = 'StyledCustomComponent';
  return component;
};

export var defaultProps = {
  appearance: 'default',
  isDisabled: false,
  isSelected: false,
  isLoading: false,
  spacing: 'default',
  type: 'button',
  shouldFitContainer: false,
  autoFocus: false
};

var Button =
/*#__PURE__*/
function (_Component) {
  _inherits(Button, _Component);

  function Button() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Button);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Button)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "button", void 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      isActive: false,
      isFocus: false,
      isHover: false
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "customComponent", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isInteractive", function () {
      return !_this.props.isDisabled && !_this.props.isLoading;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseEnter", function () {
      _this.setState({
        isHover: true
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseLeave", function () {
      return _this.setState({
        isHover: false,
        isActive: false
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseDown", function (e) {
      e.preventDefault();

      _this.setState({
        isActive: true
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMouseUp", function () {
      return _this.setState({
        isActive: false
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onFocus", function (event) {
      _this.setState({
        isFocus: true
      });

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onBlur", function (event) {
      _this.setState({
        isFocus: false
      });

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onInnerClick", function (e) {
      if (!_this.isInteractive()) {
        e.stopPropagation();
      }

      return true;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getInnerRef", function (ref) {
      _this.button = ref;
      if (_this.props.innerRef) _this.props.innerRef(ref);
    });

    return _this;
  }

  _createClass(Button, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.component !== nextProps.component) {
        delete this.customComponent;
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.autoFocus && this.button) {
        this.button.focus();
      }
    }
  }, {
    key: "getStyledComponent",
    value: function getStyledComponent() {
      if (this.props.component) {
        if (!this.customComponent) {
          this.customComponent = createStyledComponent();
        }

        return this.customComponent;
      }

      if (this.props.href) {
        return this.props.isDisabled ? StyledSpan : StyledLink;
      }

      return StyledButton;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          iconBefore = _this$props.iconBefore,
          iconAfter = _this$props.iconAfter,
          isLoading = _this$props.isLoading,
          shouldFitContainer = _this$props.shouldFitContainer,
          spacing = _this$props.spacing,
          appearance = _this$props.appearance,
          isSelected = _this$props.isSelected,
          isDisabled = _this$props.isDisabled; // $FlowFixMe - Cannot call `getButtonProps` with `this` bound to `component` because `Button` [1] is incompatible with `Button` [2].

      var buttonProps = getButtonProps(this);
      var StyledComponent = this.getStyledComponent();
      var iconIsOnlyChild = !!(iconBefore && !iconAfter && !children || iconAfter && !iconBefore && !children);
      return React.createElement(StyledComponent, _extends({
        innerRef: this.getInnerRef
      }, buttonProps), React.createElement(ButtonWrapper, {
        onClick: this.onInnerClick,
        fit: !!shouldFitContainer
      }, isLoading ? React.createElement(LoadingSpinner, {
        spacing: spacing,
        appearance: appearance,
        isSelected: isSelected,
        isDisabled: isDisabled
      }) : null, iconBefore ? React.createElement(IconWrapper, {
        isLoading: isLoading,
        spacing: buttonProps.spacing,
        isOnlyChild: iconIsOnlyChild
      }, iconBefore) : null, children ? React.createElement(ButtonContent, {
        isLoading: isLoading,
        followsIcon: !!iconBefore,
        spacing: buttonProps.spacing
      }, children) : null, iconAfter ? React.createElement(IconWrapper, {
        isLoading: isLoading,
        spacing: buttonProps.spacing,
        isOnlyChild: iconIsOnlyChild
      }, iconAfter) : null));
    }
  }]);

  return Button;
}(Component);

_defineProperty(Button, "defaultProps", defaultProps);

export var ButtonBase = Button;
export var ButtonWithoutAnalytics = withDeprecationWarnings(Button);
var createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
  componentName: 'button',
  packageName: packageName,
  packageVersion: packageVersion
})(withAnalyticsEvents({
  onClick: createAndFireEventOnAtlaskit({
    action: 'clicked',
    actionSubject: 'button',
    attributes: {
      componentName: 'button',
      packageName: packageName,
      packageVersion: packageVersion
    }
  })
})(ButtonWithoutAnalytics));