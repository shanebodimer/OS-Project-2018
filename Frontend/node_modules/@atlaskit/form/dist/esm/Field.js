import _objectSpread from "@babel/runtime/helpers/objectSpread";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

/* eslint-disable no-console */
// While in dev preview console.info will be used

/* eslint-disable react/no-unused-prop-types */
import React, { Component } from 'react';
import { colors } from '@atlaskit/theme';
import styled from 'styled-components';
import FieldWrapper, { HelperText, Label } from './styled/Field';
import { ValidatorMessage } from './';
var RequiredIndicator = styled.span.withConfig({
  displayName: "Field__RequiredIndicator",
  componentId: "sc-6y3zfq-0"
})(["\n  color: ", ";\n  padding-left: 2px;\n"], colors.red); // TODO: Decide & implement how multiple error messages should be displayed. Likely an UO list

var messageSeperator = ' ';

var Field =
/*#__PURE__*/
function (_Component) {
  _inherits(Field, _Component);

  function Field(_props) {
    var _this;

    _classCallCheck(this, Field);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Field).call(this, _props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getComponentFromProps", function (props) {
      // Field must have component passed in or a single child
      if (React.Children.only(props.children) && props.component) {
        console.warn('Field expects the component to be passed as a child OR component. Both have been passed and child is being used.');
      } else if (!React.Children.only(props.children) && !props.component) {
        console.warn('Field must have one valid child which is a field component. E.g FieldText, Select');
      }

      return React.Children.only(props.children) || props.component || {};
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getFieldStateFromProps", function (props) {
      var id = props.id,
          name = props.name,
          label = props.label,
          validators = props.validators,
          isInvalid = props.isInvalid,
          invalidMessage = props.invalidMessage,
          validMessage = props.validMessage,
          isRequired = props.isRequired,
          helperText = props.helperText,
          validateOnChange = props.validateOnChange,
          validateOnBlur = props.validateOnBlur,
          validateOnInvalid = props.validateOnInvalid;

      var childComponent = _this.getComponentFromProps(props);

      var fieldState = {
        validators: validators,
        isInvalid: isInvalid,
        invalidMessage: invalidMessage,
        validMessage: validMessage,
        isRequired: isRequired,
        name: childComponent.props.name || name,
        id: childComponent.props.id || id || name,
        label: childComponent.props.label || label,
        value: childComponent.props.value || '',
        validate: _this.validate,
        helperText: helperText,
        validateOnChange: validateOnChange,
        validateOnBlur: validateOnBlur,
        validateOnInvalid: validateOnInvalid,
        componentType: childComponent.props.componentType || childComponent.type.name,
        invalidMessages: []
      }; // For some components like Checkbox that are wrapped in withTheme and exported via anon function
      // we need to check for known props to idenitfy them. TODO: Fix this in the affected components and remove this hack

      if (!fieldState.componentType || !fieldState.componentType.length) {
        // Checkbox stateless
        if (childComponent.props.isChecked !== undefined) fieldState.componentType = 'CheckboxStateless';
      }

      return fieldState;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getValueFromEvent", function () {// Can we use
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleOnChange", function (event, meta) {
      var fieldState = _this.state.fieldState; // Call any onChange defined for Field or the component.
      // This is required to support stateless components

      if (_this.state.component.props && _this.state.component.props.onChange) {
        _this.state.component.props.onChange(event);
      } // TODO: review if we need to expose this? Might make more sense to just have an onUpdate which fires
      // when fieldState is updated


      if (_this.props.onChange) {
        _this.props.onChange(event, meta);
      } // TODO: move mapping event types to field components to json
      // Most Inputs - Event from HTMLInput | Event
      // Checkbox


      if (_this.state.fieldState.componentType === 'Checkbox') {
        fieldState.value = event.isChecked ? event.value : ''; // Stateless checkbox
      } else if (_this.state.fieldState.componentType === 'CheckboxStateless') {
        fieldState.value = event.currentTarget.checked ? event.currentTarget.value : ''; // Most Inputs - Event from HTMLInput | Event
      } else if (event && event.target) {
        fieldState.value = event.target.value || ''; // Strings from inputs, objects & arrays of objects from select
      } else if (event) {
        fieldState.value = event; // Default to empty string
      } else {
        fieldState.value = '';
      } // Update Field State and pass on


      _this.setState({
        fieldState: fieldState
      }); // Update form field state from the validate result or use the current state


      if (_this.props.validateOnChange) {
        _this.updateFormState(_this.validate());
      } else {
        _this.updateFormState(_this.state.fieldState);
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleOnBlur", function () {
      if (_this.props.validateOnBlur) {
        _this.updateFormState(_this.validate());
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "validate", function () {
      var _this$state$fieldStat = _this.state.fieldState,
          validators = _this$state$fieldStat.validators,
          value = _this$state$fieldStat.value;
      var isRequired = _this.props.isRequired;

      var _this$state$fieldStat2 = _this.state.fieldState,
          isInvalid = _this$state$fieldStat2.isInvalid,
          invalidMessage = _this$state$fieldStat2.invalidMessage,
          validMessage = _this$state$fieldStat2.validMessage,
          invalidMessages = _this$state$fieldStat2.invalidMessages,
          rest = _objectWithoutProperties(_this$state$fieldStat2, ["isInvalid", "invalidMessage", "validMessage", "invalidMessages"]);

      var result = true;
      var invalid = '';
      var valid = '';
      var invalidCount = 0;
      var validatedFieldState = {}; // Is the field required?

      if (isRequired && !value || isRequired && !String(value).trim().length) {
        invalidCount++;
        invalid = 'This field is required';
      } else if (validators && validators.length) {
        for (var i = 0; i < validators.length; i++) {
          if (validators[i].props.func) {
            result = validators[i].props.func(value, validators[i].props.options); // Invert result if validOn prop is false

            if (validators[i].props.validOnFalse) result = !result; // Most validators will only have an invalid message

            if (result) {
              valid = valid.concat(validators[i].props.valid + messageSeperator);
            } else {
              invalidCount++;
              invalid = invalid.concat(validators[i].props.invalid + messageSeperator);
              invalidMessages.push(validators[i].props.invalid);
            }
          }
        }
      }

      validatedFieldState = {
        fieldState: _objectSpread({
          isInvalid: !!invalidCount,
          invalidMessage: invalid,
          invalidMessages: invalidMessages,
          validMessage: valid
        }, rest)
      };

      _this.setState(validatedFieldState);

      return validatedFieldState.fieldState;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateFormState", function (fieldState) {
      if (_this.props.form && _this.props.form.setFieldState) {
        _this.props.form.setFieldState(fieldState || _this.state.fieldState);
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderLabel", function () {
      if (_this.props.label && _this.props.label.length) {
        return React.createElement(Label, {
          htmlFor: _this.props.id
        }, _this.props.label, _this.props.isRequired ? React.createElement(RequiredIndicator, {
          role: "presentation"
        }, "*") : null);
      }

      return null;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderFieldComponent", function () {
      var _this$state$fieldStat3 = _this.state.fieldState,
          id = _this$state$fieldStat3.id,
          name = _this$state$fieldStat3.name,
          isInvalid = _this$state$fieldStat3.isInvalid,
          isRequired = _this$state$fieldStat3.isRequired,
          label = _this$state$fieldStat3.label,
          invalidMessage = _this$state$fieldStat3.invalidMessage;
      var component = _this.state.component;
      var validationState = 'default';

      if (component) {
        // validationState & validationMessage are used to support AtlaskitSelect dev preview
        if (isInvalid !== undefined) {
          validationState = isInvalid ? 'error' : 'success';
        }

        return React.cloneElement(component, {
          id: id,
          name: name,
          isInvalid: isInvalid,
          isRequired: isRequired,
          label: label,
          invalidMessage: invalidMessage,
          isLabelHidden: true,
          isValidationHidden: true,
          validationMessage: invalidMessage,
          validationState: validationState,
          onChange: _this.handleOnChange,
          onUpdate: _this.handleOnChange,
          onBlur: _this.handleOnBlur
        });
      }

      return null;
    });

    _this.state = {
      fieldState: _this.getFieldStateFromProps(_props),
      component: _this.getComponentFromProps(_props)
    }; // Register the field in the parent form if there is one

    if (_props.form && _this.state.fieldState) _props.form.registerField(_this.state.fieldState);
    return _this;
  }
  /** Register the field in the form if there is one */


  _createClass(Field, [{
    key: "componentDidMount",
    value: function componentDidMount() {}
    /** Handle prop or children prop changes */

  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.setState({
        fieldState: this.getFieldStateFromProps(nextProps),
        component: this.getComponentFromProps(nextProps)
      });
    }
    /** Return the component from children or the component prop */

  }, {
    key: "render",

    /**
     * When we render Label, Helper & Validation are only handled only if passed as props. This allows for
     * components that currently roll their own to still be wrapped by Field.
     */
    value: function render() {
      var _this$state$fieldStat4 = this.state.fieldState,
          helperText = _this$state$fieldStat4.helperText,
          isInvalid = _this$state$fieldStat4.isInvalid,
          invalidMessage = _this$state$fieldStat4.invalidMessage,
          validMessage = _this$state$fieldStat4.validMessage;
      return React.createElement(FieldWrapper, null, this.renderLabel(), this.renderFieldComponent(), helperText && helperText.length ? React.createElement(HelperText, null, helperText) : null, React.createElement(ValidatorMessage, {
        isInvalid: isInvalid,
        validMessage: validMessage,
        invalidMessage: invalidMessage
      }));
    }
  }]);

  return Field;
}(Component);

_defineProperty(Field, "defaultProps", {
  validators: [],
  isInvalid: undefined,
  invalidMessage: '',
  validMessage: '',
  helperText: '',
  validateOnChange: false,
  validateOnBlur: true,
  validateOnInvalid: true
});

export { Field as default };